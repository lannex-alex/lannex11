import base64
from datetime import datetime
import json
import logging
import pytz
import requests
import uuid

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from datetime import timedelta
from urllib.parse import quote_plus

from ..controllers.main import OAUTH2_CALLBACK_ROUTE

DEMO_URL = "https://api-demo.airwallex.com"
DEMO_FILE_URL = "https://files-demo.airwallex.com"
DEMO_OAUTH2_URL = "https://demo.airwallex.com"

DEMO_OAUTH2_CLIENT_ID = 'appid_B4U3Jx5jTbgBfZH1ccEW'
DEMO_OAUTH2_SECRET = 'QmjdAMF8IiC5yDbjFpDpGKLqfM0DTmPrDOvzrr9DWKPoVlfvG9PuiKLfe340g0et'
PROD_OAUTH2_CLIENT_ID = 'appid_upHw9dp2s4TSGAfBDMpf'
PROD_OAUTH2_SECRET = '7mr7PTiTUxRkeQkgsgW2qY3ZsDRLvfX2zzXcJ2jKfoZE5dtXZTIIqy2HkEJC4AHT'

URL = "https://api.airwallex.com"
FILE_URL = "https://files.airwallex.com"

AUTHENTICATION_ENDPOINT = "/authentication/login"
AIRWALLEX_BALANCE_ENDPOINT = '/balances/current'
AIRWALLEX_BALANCE_HISTORY_ENDPOINT = '/balances/history'
AIRWALLEX_ACCOUNT_ENDPOINT = '/account'
REQUEST_TIMEOUT = 5
JSON_HEADERS = {"Content-Type": "application/json"}
ISO_FORMAT_DATETIME = "%Y-%m-%dT%H:%M:%S%z"

OAUTH2_URL = 'https://airwallex.com'
OAUTH2_AUTHORIZATION_ENDPOINT = '/oauth/authorize?response_type=code&'
OAUTH2_TOKEN_ENDPOINT = '/oauth/token'
OAUTH2_ALLOWED_SCOPES = [
    'r:awx_action:balances_view',
    'r:awx_action:settings.account_details_view',
    # 'r:awx_action:financial_transactions_view',
    # 'r:awx_action:global_accounts_view',
    # 'r:awx_action:contact_management_view',
    # 'r:awx_action:transfers_view',
    # 'r:awx_action:issuing_cards_view',
    # 'r:awx_action:issuing_cardholders_view',
    # 'r:awx_action:issuing_transactions_view',
    # 'r:awx_action:payment_links_view',
    # 'r:awx_action:pa_view',
    # 'w:awx_action:global_accounts_edit',
    # 'w:awx_action:contact_management_edit',
    # 'w:awx_action:transfers_edit',
    # 'w:awx_action:issuing_cards_edit',
    # 'w:awx_action:issuing_cardholders_edit',
    # 'w:awx_action:payment_links_edit',
    # 'w:awx_action:pa_edit',
    # 'w:awx_action:onboarding',
]

_logger = logging.getLogger(__name__)

class AirwallexAccount(models.Model):
    _name = "airwallex.account"
    _description = "Airwallex Account configuration"

    name = fields.Char(help="Description name of the airwallex account")
    company_id = fields.Many2one(
        comodel_name="res.company", default=lambda r: r.env.company)
    environment = fields.Selection(
        selection=[('demo', 'Demo'), ('production', 'Production')], required=True, default="demo")
    auth_type = fields.Selection([('oauth2', 'Oauth2'), ('api', 'API')], string='Authentication Type', default='oauth2')

    oauth2_client_id = fields.Char('OAuth2 Client ID', compute="_compute_oauth_credentials", help="The ID of your application issued by Airwallex", store=True)
    oauth2_secret = fields.Char('OAuth2 Secret', compute="_compute_oauth_credentials", help="The secret of your application issued by Airwallex", store=True)
    oauth2_refresh_token = fields.Char('OAuth2 Refresh Token', help="The authorization code generated by Airwallex as a result of the OAuth2 authentication")
    oauth2_refresh_token_expired_at = fields.Datetime('OAuth2 Refresh Token Expired At')
    oauth2_error = fields.Char('OAuth2 Error', help="Returned error code")
    oauth2_state = fields.Char('OAuth2 State', help="Token to pair the OAuth response")

    api_key = fields.Char(help="API key provided by Airwallex")
    client_id = fields.Char(help="Client ID provided by Airwallex")

    token = fields.Char()
    expired_at = fields.Datetime()

    airwallex_statement_ids = fields.One2many("airwallex.statement", "airwallex_account_id")
    is_balance_created = fields.Boolean(default=False)

    sync_period = fields.Selection(selection=[('hourly', 'Hourly'), ('daily', 'Daily'), ('weekly', 'Weekly')], default="daily")
    bank_statement_period = fields.Selection(selection=[('daily', 'Daily'), ('weekly', 'Weekly'), ('monthly', 'Monthly')], default="daily")
    airwallex_balance_ids = fields.One2many("airwallex.balance", "airwallex_account_id")
    airwallex_account_created_at = fields.Datetime()
    airwallex_account_info = fields.Text()
    active = fields.Boolean(default=True)

    @api.depends('environment')
    def _compute_oauth_credentials(self):
        for rec in self:
            if rec.environment == 'production':
                rec.oauth2_client_id = PROD_OAUTH2_CLIENT_ID
                rec.oauth2_secret = PROD_OAUTH2_SECRET
            else:
                rec.oauth2_client_id = DEMO_OAUTH2_CLIENT_ID
                rec.oauth2_secret = DEMO_OAUTH2_SECRET


    def get_version(self):
        return '/api/v1'

    @api.model
    def _format_date_from_airwallex(self, _datetime):
        return datetime.strptime(_datetime, ISO_FORMAT_DATETIME).astimezone(pytz.UTC).replace(tzinfo=None)

    @api.model
    def _format_date_to_airwallex(self, _datetime):
        return _datetime.astimezone(pytz.UTC).strftime(ISO_FORMAT_DATETIME)

    def _get_auth_url(self):
        self.ensure_one()
        return OAUTH2_URL if self.environment == 'production' else DEMO_OAUTH2_URL

    def _get_url(self):
        self.ensure_one()
        return URL if self.environment == 'production' else DEMO_URL

    def _get_file_url(self):
        self.ensure_one()
        return FILE_URL if self.environment == 'production' else DEMO_FILE_URL

    def _get_redirect_url(self):
        # 'https://awx15.dev.portcities.cc'
        host = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
        return host.strip('/') + OAUTH2_CALLBACK_ROUTE

    def get_token(self, force_new=False):
        self.ensure_one()
        if not force_new and self.token and self.expired_at > datetime.now():
            return self.token

        return self.authenticate()

    def get_client_oauth2(self):
        self.ensure_one()
        if not self.oauth2_client_id:
            raise UserError(_("Please enter an OAuth2 Client ID"))
        if not self.oauth2_secret:
            raise UserError(_("Please enter an OAuth2 Secret"))
        if not self.oauth2_state:
            self.oauth2_state = str(uuid.uuid4())

        oauth2_url = self._get_auth_url() +  OAUTH2_AUTHORIZATION_ENDPOINT
        url = oauth2_url + '&'.join([key + '=' + quote_plus(value) for key, value in [
            ('client_id', self.oauth2_client_id),
            ('redirect_uri', self._get_redirect_url()),
            ('scope', ' '.join(OAUTH2_ALLOWED_SCOPES)),
            ('state', self.oauth2_state),
        ]])

        return {
            'url': url,
            'type': 'ir.actions.act_url',
        }

    def authenticate(self):
        self.ensure_one()
        # Call Account API
        res = False
        if self.auth_type == 'oauth2':
            res = self.auth_oauth2()
        elif self.auth_type == 'api':
            res = self.auth_api()

        account_info = self.call_airwallex_api(AIRWALLEX_ACCOUNT_ENDPOINT, method='GET')
        self.update_account_information(account_info)

        return res

    def update_account_information(self, account_info):
        self.ensure_one()
        self.sudo().write({
            "airwallex_account_created_at": self._format_date_from_airwallex(account_info.get('created_at')),
            'airwallex_account_info': json.dumps(account_info)
        })

    def auth_oauth2(self):
        self.ensure_one()
        if not self.oauth2_client_id:
            raise UserError(_("Please enter an OAuth2 Client ID"))

        if self.oauth2_refresh_token and (not self.oauth2_refresh_token_expired_at or self.oauth2_refresh_token_expired_at > datetime.now()):
            return self.refresh_oauth2_token()

        raise UserError(_("The OAuth2 authotisation expired - please reconnect"))

    def refresh_oauth2_token(self):
        self.ensure_one()
        if not self.oauth2_client_id:
            raise UserError(_("Please enter an OAuth2 Client ID"))
        if not self.oauth2_secret:
            raise UserError(_("Please enter an OAuth2 Secret"))
        data = {
            "client_id": self.oauth2_client_id,
            "client_secret": self.oauth2_secret,
            "grant_type": "refresh_token",
            "refresh_token": self.oauth2_refresh_token
        }
        generate_code_response = self.call_airwallex_api(OAUTH2_TOKEN_ENDPOINT, params=data, is_authentication='oauth2')
        self.write_oauth2_info(generate_code_response)

    def generate_oauth2_token(self, post):
        code_verifier = base64.b64encode(str(uuid.uuid4()).encode('utf8')).decode('utf8')
        self.env['airwallex.auth.log'].sudo().create({
            'post': post,
            'code_verifier': code_verifier,
        })
        self.ensure_one()
        if not self.oauth2_client_id:
            raise UserError(_("Please enter an OAuth2 Client ID"))
        if not self.oauth2_secret:
            raise UserError(_("Please enter an OAuth2 Secret"))
        if post.get('error'):
            self.write({'oauth2_error': post['error']})
            return

        code = post.get('code')
        data = {
            "client_id": self.oauth2_client_id,
            "client_secret": self.oauth2_secret,
            "code": code,
            "grant_type": "authorization_code",
            "redirect_uri": self._get_redirect_url()
        }

        _logger.info("Getting token: %s", json.dumps(data))
        generate_code_response = self.call_airwallex_api(OAUTH2_TOKEN_ENDPOINT, params=data, is_authentication='oauth2')
        self.write_oauth2_info(generate_code_response)
        account_info = self.call_airwallex_api(AIRWALLEX_ACCOUNT_ENDPOINT, method='GET')
        self.update_account_information(account_info)

    def write_oauth2_info(self, generate_code_response):
        self.sudo().write({
            'token': generate_code_response.get('access_token'),
            'expired_at': datetime.now() + timedelta(seconds=generate_code_response.get('expires_in', 0)),
            'oauth2_refresh_token': generate_code_response.get('refresh_token'),
            'oauth2_refresh_token_expired_at': datetime.now() + timedelta(seconds=generate_code_response.get('refresh_token_expires_in', 0)),
            'oauth2_error': False,
        })

    def unlink(self):
        self.env['airwallex.balance'].search([('airwallex_account_id', 'in', self.ids)]).sudo().unlink()
        self.env['airwallex.statement'].search([('airwallex_account_id', 'in', self.ids)]).sudo().action_archive()
        return super().unlink()

    def auth_api(self):
        if not self.client_id or not self.api_key:
            raise UserError(_("Please enter a client ID and an API key to test the authentication"))
        response = self.call_airwallex_api(AUTHENTICATION_ENDPOINT, payload="{}", is_authentication='api')

        token = response.get('token')
        expired_at = response.get('expires_at')

        if expired_at:
            expired_at = self._format_date_from_airwallex(expired_at)

        self.write({
            "token": token,
            "expired_at": expired_at,
        })

        return token

    def call_airwallex_api(
            self, endpoint, method="POST", payload=None, is_file=False,
            is_authentication=False, force_new=False, headers=False, params=False, retry=False
    ):
        self.ensure_one()
        base_url = self._get_file_url() if is_file else self._get_url()
        if is_authentication != 'oauth2':
            base_url += self.get_version()

        url = f"{base_url}{endpoint}"
        optional_param = {}

        if not headers:
            headers = JSON_HEADERS
        else:
            headers.update(JSON_HEADERS)

        if params:
            optional_param.update({
                "params": params,
            })

        if is_authentication == 'api':
            headers.update({
                "x-api-key": self.api_key,
                "x-client-id": self.client_id
            })
        elif not is_authentication:
            headers.update({
                "Authorization": f"Bearer {self.get_token(force_new=force_new)}"
            })

        req = requests.request(
            method=method, headers=headers, url=url, timeout=REQUEST_TIMEOUT, data=payload, **optional_param)

        if req.status_code in [requests.codes.OK, requests.codes.CREATED]:
            try:
                return req.json()
            except Exception as err:
                raise UserError(_("ERROR reponse was not beein able to be formated into JSON %s", req.text)) from err

        if req.status_code == 401 and not retry:
            return self.call_airwallex_api(endpoint, method=method, payload=payload, is_file=is_file,
            is_authentication=is_authentication, force_new=True, headers=headers, params=params, retry=True)

        try:
            error_reponse = req.json()
        except Exception as err:
            _logger.warning("Was not able to transform the error message to JSON %s", err)
            error_reponse = {"message": f"{err}"}

        raise UserError(_(
            "An error occured when we call the API "
            "- HTTP code: %(http_code)s - error code: %(code)s - message: %(message)s "
            "- Contact your admin with those information to find a solution",
            http_code=req.status_code, code=error_reponse.get('code'), message=error_reponse.get('message', error_reponse)))

    def action_test(self):
        return 'OK'

    def get_financial_transactions_response(self, page_num, date_from=False, date_to=False, currency=False):
        params = {
            "page_size": 500,
            "page_num": page_num
        }

        if date_from:
            params.update({
                "from_post_at": self._format_date_to_airwallex(date_from)
            })

        if date_to:
            params.update({
                "to_post_at": self._format_date_to_airwallex(date_to)
            })

        if currency:
            params.update({
                "currency": currency
            })

        response = self.call_airwallex_api(AIRWALLEX_BALANCE_HISTORY_ENDPOINT, method="GET", params=params)

        return response

    def create_airwallex_statements(self, response):
        return self.env['airwallex.statement'].sudo().create({
            'airwallex_account_id': self.id,
            'api_response': str(response)
        })

    def process_statement_response(self, api_response):
        """
        - Group items per currency
        - Find the associated airwallex.balance - search([acount_id = self.id, currency = currency])
        - If none is found then ignore the batch
        - Process items from each batch ( provided that it has journal on balance, else ignore )
        """,
        airwallex_statement = self.create_airwallex_statements(api_response)
        response_items = api_response.get("items")

        items_by_currency = {}
        for item in response_items:
            items_by_currency.setdefault(item['currency'], []).append(item)

        balance_ids = self.env['airwallex.balance'].search(
            [('airwallex_account_id', '=', self.id), ('currency_id.name', 'in', list(items_by_currency.keys()))])

        for currency, item_currency in items_by_currency.items():
            balance_id = balance_ids.filtered(lambda r: r.currency_id.name == currency)
            if balance_id and balance_id.journal_id:
                balance_id.process_items(item_currency, airwallex_statement)

    def fetch_transactions(self, page_num=0, date_from=False, date_to=False, currency=False, get_balance=True):
        # Gets the response items and create logs out of it
        self = self.sudo().with_context(airwallex_creation=True)
        if get_balance:
            self.get_airwallex_balance(currency=currency)
        api_response = self.get_financial_transactions_response(
                                                        page_num=page_num, date_from=date_from, date_to=date_to, currency=currency)
        self.process_statement_response(api_response)

        if api_response.get("hasMore"):
            return self.fetch_transactions(
                                page_num=page_num + 1, date_from=date_from, date_to=date_to, currency=currency, get_balance=get_balance)

        return True

    def action_get_list_transactions(self, fetchall=False):
        if fetchall:
            all_airwallex_account_ids = self.search([('api_key', '!=', False), ('client_id', '!=', False)])
        else:
            all_airwallex_account_ids = self
        last_check_datetime = dict(
            (item['airwallex_account_id'][0], item['last_sync_datetime']) \
                for item in self.env['airwallex.balance'].read_group(
                    domain=[('airwallex_account_id', 'in', all_airwallex_account_ids.ids)],
                    fields=['last_sync_datetime:min'], groupby=['airwallex_account_id'])
        )
        for record in all_airwallex_account_ids:
            try:
                record.fetch_transactions(date_from=last_check_datetime.get(record.id))
            except Exception as err:
                _logger.warning("An error occurer when we try to refresh the transaction - %s", err)

    def get_airwallex_balance(self, currency=False):
        self.ensure_one()
        if not self.is_balance_created:
            self.sudo().write({
                'is_balance_created': True
            })
        params = {}
        airwallex_balance_sudo =  self.env['airwallex.balance'].sudo()
        if currency:
            params.update({
                "currency": currency
            })
        balances_from_api = self.call_airwallex_api(AIRWALLEX_BALANCE_ENDPOINT, method='GET', params=params)
        existing_balances = airwallex_balance_sudo.search([('airwallex_account_id', '=', self.id)])
        for balance in balances_from_api:
            currency = self.env['res.currency'].search([('name', '=', balance.get('currency'))], limit=1)
            if currency:
                balance_vals = {
                    'airwallex_account_id': self.id,
                    'currency_id': currency.id,
                    'available_amount': balance.get('available_amount'),
                    'pending_amount': balance.get('pending_amount'),
                    'reserved_amount': balance.get('reserved_amount'),
                    'total_amount': balance.get('total_amount'),
                }
                existing_balance = existing_balances.filtered(lambda r: r.currency_id.id == currency.id)
                if existing_balance:
                    if not existing_balance.journal_id:
                        balance_vals.update({
                            'last_sync_datetime': fields.Datetime.now(),
                        })
                    existing_balance.write(balance_vals)
                else:
                    balance_vals.update({
                        'last_sync_datetime': fields.Datetime.now(),
                    })
                    airwallex_balance_sudo.create(balance_vals)


    def trigger_cron(self, xml_id, interval_number):

        def period_to_number(interval = None):
            switcher = {
                'hourly': ("hours", 1),
                'daily': ("days", 1),
                'weekly': ("days", 7),
                'monthly': ("days", 30),
            }

            return switcher.get(interval)

        timedelta_params = period_to_number(interval_number)
        nextcall = fields.Datetime.now() + timedelta(**dict([timedelta_params]))

        self.env.ref(xml_id).write({
            'interval_type': timedelta_params[0],
            'interval_number': timedelta_params[1],
            'nextcall': nextcall
        })

    """
     Each statement_id has associated button_post function
    """
    def post_bank_statements(self):
        all_airwallex_account_ids = self.search([('api_key', '!=', False), ('client_id', '!=', False)])
        journal_ids = all_airwallex_account_ids.airwallex_balance_ids.journal_id.ids
        bank_statement_ids = self.env['account.bank.statement'].search([('journal_id', 'in', journal_ids), ('state', '=', 'open')])
        for statement in bank_statement_ids:
            statement.button_post()

    @api.constrains('sync_period')
    def _onchange_sync_period(self):
        self.trigger_cron('airwallex.account_ir_cron', self.sync_period)

    @api.constrains('bank_statement_period')
    def _onchange_bank_statement_period(self):
        self.trigger_cron('airwallex.account_bank_statement_ir_cron',self.bank_statement_period)
